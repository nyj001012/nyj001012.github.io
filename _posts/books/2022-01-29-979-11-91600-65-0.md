---
title: "프로그래머의 뇌: 훌륭한 프로그래머가 알아야 할 인지과학의 모든 것"
excerpt: "펠리너 헤라만스, '프로그래머의 뇌: 훌륭한 프로그래머가 알아야 할 인지과학의 모든 것'를 읽고"
category: 
  - books
author_profile: true
sidebar:
  - nav: "main" 
tag: 
  - "프로그래머의 뇌: 훌륭한 프로그래머가 알아야 할 인지과학의 모든 것"
  - 펠리너 헤라만스
toc: true
toc_sticky: true
last_modified_at: 2022-01-29T00:00:00+09:00
---

> 이 포스트는 [펠리너 헤라만스, '프로그래머의 뇌: 훌륭한 프로그래머가 알아야 할 인지과학의 모든 것'](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791191600650)를 읽고 작성하였습니다.

# 책을 읽기 전
소제목에 '훌륭한 프로그래머가 알아야 할 인지과학의 모든 것'임을 보아 프로그래머들이 어떻게 생각하는지를 알려주려 하는 게 아닐까 했다.  
그런데 막상 목차를 살펴보니, 'Chapter 1 코딩 중 겪는 혼란에 대한 이해'를 제외하고는 크게 인지과학적인 내용이 없어 보였다(휴...).

아래에는 내가 이 책을 읽으면서 든 생각이나 정리할 것을 적어놓았다.  

# Part 1. 코드 더 잘 읽기

## Chapter 1. 코딩 중 겪는 혼란에 대한 이해

> 코드가 초래하는 세 가지 종류의 혼란  
> 1. 지식의 부족
> 2. 정보의 부족
> 3. 처리 능력의 부족

책에서는 코딩 중 겪는 혼란을 위의 세 가지로 분류했는데, 지식의 부족에 대한 예는 다음과 같다.  
아래의 코드는 APL에서 숫자 n을 이진수로 변환하는 코드다.

```apl
2 2 2 2 2 T n
```
난 처음에 이 코드를 보고 ? 했다. 이게 뭐지? T는 부호고 2 개수만큼 자리를 채우는 건가? 이런 일이 발생하는 건, 내가 APL에 대한 지식이 없기 때문이다.

정보의 부족으로는 자바에서의 'toBinaryString()'을 예로 들었다. 메서드 이름만 딱 봐도 이진수로 변환하는 역할을 하는 것 같은데, 이 메서드가 구체적으로 어떤 일을 수행하는지 이해하려면 메서드 내부를 더 살펴봐야 한다고 저자는 말한다. 이게 번역되는 과정에서 뉘앙스가 누락된 건지, 뭔가 이해가 잘 안 됐다. '메서드 이름으로는 기능을 추측할 수 있지만, 꼭 그게 정답이란 법은 없으니 그 메서드를 모르는 것과 같다. 따라서 그 메서드를 모르기 때문에 혼란이 생긴다.'의 말인 건가 했다.

처리 능력의 오류는 이미 많이 겪어 봤었다. 파이썬에서 numpy로 다차원 행렬을 다룰 때, 여러 연산을 거치며 바뀌는 행렬의 값을 일일이 다 기억하기는 어렵다. 따라서 나는 연산 결과의 shape만 주석으로 적어놓곤 했다.

위의 세 가지 혼란과 연관된 인지 과정은 다음과 같다.

> 코딩에 영향을 주는 인지 과정
> 지식의 부족 = LTM의 문제
> 정보의 부족 = STM의 문제
> 처리 능력의 부족 = 작업 기억 공간의 문제

자, LTM, STM, 작업 기억 공간이 뭔지를 알아야 할텐데, 우선 LTM은 장기 기억 공간이다. LTM은 기억하는 내용을 반 영구적으로 저장하는 곳으로, 지식이 없다는 것은 LTM에 해당 내용이 없다는 것을 뜻한다. 컴퓨터의 하드 드라이브와 비슷하다.  
STM은 단기 기억 공간이다. 정보가 부족할 때는 STM에 해당 내용이 없다는 뜻이다. 정보를 수집할 때 단기 기억 장소에 일시적으로 저장하지만, 다른 정보를 찾는 과정에서 이미 수집해놓은 정보 중 일부는 잊어버린다. 컴퓨터의 캐시나 메인 메모리라고 할 수 있다.  
작업 기억 공간은 우리가 사고할 때 사용하는 영역이다.

이 인지과정이 어떻게 코딩과 연결될까?

특정 프로그래밍 언어의 키워드나 문법, 프로그램을 작성할 때의 추상적인 알고리즘은 LTM에 저장된다. 그리고 내가 코드를 읽을 때 이게 무슨 언어인지, 이 키워드는 뭘 의미하는지를 LTM에서 인출한다.  
STM에는 키워드, 변수명, 자료구조 등이 일시적으로 저장된다.  
STM의 예시에서 재밌는 걸 하나 찾았는데,
```java
public class BinaryCalculator {
    public static void mian(Integer n) {
        System.out.println(Integer.toBinaryString(n));
    }
}
```
여기서 부자연스러운 게 있을 것이다. 바로 `main` 메서드가 아니라 `mian` 메서드라고 명명된 것이다. 내가 수능 준비할 때 영어 지문으로 어디선가 "사람들은 오타를 무의식적으로 교정해서 읽는다."와 같은 내용을 본 적이 있다. 저자에 따르면 이 과정은 오타를 읽을 때 오타가 STM에 저장되는데, LTM에 저장된 교정된 단어를 사용함으로써 일어난다. 즉, STM과 LTM은 독립적으로 일어나는 것이 아니다.  
작업 기억 공간에서는 생각, 아이디어, 해결책 같은 것들이 만들어진다.

뭔가 프로그래밍에 있어서 묘하게 LTM과 STM의 구분이 모호한 감이 없잖아 있는데... 코드를 보는 시점에 따라 구분되는 것 같다. 내가 지금 보는 건 STM, 지금 보고 있지 않지만 기억하는 것은 LTM이라고 봐야할 것 같다.

이 인지 과정들은 정보가 들어오면 필터를 거쳐 STM에 저장된다. 그리고 작업 기억 공간에 STM의 정보와 LTM의 정보가 같이 들어와 합쳐지고 처리된다.

## Chapter 2. 신속한 코드 분석

코드를 분석하고 다시 코드를 작성하는 것은 생각보다 쉽지 않다. 나도 기능을 구현할 때 모르는 부분은 코드를 찾아보고, 그 코드를 보지 않고 재현하려 할 때 어려움이 있었는데, 이는 STM의 용량에 제한이 있기 때문이다. 저자는 이 문제를 해결하기 위해 여러 방식을 제안했다.

1. 디자인 패턴의 사용
2. 주석문 쓰기
3. 표식 남기기

위의 세 방법은 코드에서의 청킹을 잘 할 수 있게 해준다. 코드에서의 청킹은 말 그대로 코드를 청크로 나누는 것이다. 저자는 더흐로트의 체스 실험으로 청크를 설명했다. 해당 실험은 전문가와 일반인 두 그룹이 체스 말의 위치를 어떻게 기억하는지를 연구한 것인데, 전문가 그룹은 LTM에 저장된 지식을 활용해서 말의 위치를 기억했다는 내용이었다. 여기서 LTM에 저장된 지식, 몇 개의 그룹으로 묶은 정보를 청크라고 한다.

그렇다면 청킹을 연습하려면 어떻게 해야할까?  
저자는 청킹을 의도적으로 연습하기 위해서는 적극적으로 코드를 기억해내는 것을 훈련하면 좋다고 하며 다음의 단계를 제시했다.

1. 코드 선정 - 어느 정도 익숙한 코드 베이스에서 메서드나 함수 혹은 밀접하게 연결되어 있는 코드 선정. 최대 50라인.
2. 코드 파악 - 최대 2분 동안 코드 파악. 시간이 다 되면 코드는 보지 말 것.
3. 코드 재현 - 종이나 IDE에 코드 재현.
4. 회고
    1. 어느 부분을 쉽게 기억했는가?
    2. 부분적으로 기억한 코드가 있는가?
    3. 전체를 다 기억하지 못한 코드가 있는가?
    4. 기억하지 못한 라인들이 있다면 그 이유가 무엇인가?
    5. 기억하지 못한 라인에 본인이 익숙하지 않은 프로그래밍 개념이 들어 있지는 않은가?
    6. 기억하지 못한 라인에 본인이 익숙하지 않은 도메인 지식이 있지는 않은가?
5. 다른 사람과 비교(생략 가능)

전체적으로 신속한 코드 분석을 위해서는 코드를 청킹하는 게 도움이 되고, 청킹을 어떻게 연습하는지를 알려주는 챕터 같았다.

## Chapter 3. 프로그래밍 문법 빠르게 배우기

정보를 기억하는 두 가지 형태로 저장 강도와 인출 강도가 있는데, 저장 강도는 무언가를 LTM에 얼마나 잘 저장하고 있는지를 나타낸다.  
인출 강도는 무언가를 얼마나 쉽게 기억할 수 있는지를 나타낸다.  
프로그래밍 언어의 특정 문법을 기억하려고 할 때는 종종 저장 강도가 아닌 인출 강도에 있다.  
매번 문법을 필요할 때마다 찾아보기만 하면 인출 강도를 강화할 수 없다(뜨끔했다). 그러다 인출 강도가 약해지고 외우는 대신 계속 찾아보는 악순환이 이어진다. 따라서 기억을 강화해야 한다.

책에서는 무엇이든 신속하게 학습할 수 있으면서 기억을 강화하는 방법 중 하나로 플래시카드를 소개한다. 플래시카드를 프로그래밍에 활용할 때에는 앞면에 개념을 적어놓고 뒷면에 해당하는 코드를 적는 방식을 사옹한다. 나의 경우에는 퀴즐렛으로 http 강의를 들으며 정리한 개념을 세트로 만들기로 했다. 세트를 만들면 이곳에 링크를 공개하도록 하겠다.

정보를 더 잘 기억하고 싶다면 그 정보를 정교화 하는 것도 도움이 된다고 한다. 정교화는 기억하고자 하는 내용을 기존 기억과 연관 지으면서 생각하는 것을 뜻한다(내가 제일 많이 하는 거다). 새로운 정보를 학습할 때 그 정보는 LTM에 저장하기 전에 스키마의 형태로 만들어지고, 정교화를 거치면서 그 정보가 LTM에 이미 저장되어 있는 스키마에 맞춰서 저장된다. 이는 인출 강도를 강화하는 데 도움을 준다고 한다.

## Chapter 4. 복잡한 코드 읽는 방법

작업 기억 공간도 특정한 문제에 적용된 STM이기 때문에 용량 제한이 있는데, 이 용량을 인지 부하라고 한다. 너무 많은 요소가 있어 청크로 나뉘지 않는 문제를 풀려고 할 때 작업 기억 공간은 과부하 상태가 된다.

인지 부하의 종류로는 다음과 같은데,

| 부하 종류 | 설명 |
|:--------------:|--------|
| 내재적 부하 | 문제 자체가 얼마나 복잡한지 |
| 외재적 부하 | 외부적 요인에 의해 문제에 추가된 것 |
| 본유적 부하 | 생각을 LTM에 저장하는 과정에서 일어나는 인지 부하 |

이러한 인지 부하를 줄이기 위한 기법으로 아래의 방법들이 있다.
- 리팩터링
- 생소한 언어 구성 요소를 다른 것으로 대치하기
- 플래시카드에 코드 동의어 추가

리팩터링은 외부적으로 제공하는 기능은 유지한 채 코드의 내부 구조를 개성하는 것을 의미한다(리팩터링을 하면 집안 대청소를 마치고 깨끗해진 집을 보는 기분이 든다. 개운함).  그 중엔 유지 보수보다는 장기적으로 가독성이 높은 코드를 작성하도록 하는 인지적 리팩터링도 있다. 인지적 리팩터링은 때론 역 리팩터링을 수반할 수 있다. 또 다른 방법으로 메서드의 순서를 바꾸는 방법도 있다. 나는 개인적으로 연관이 있는 메서드끼리 이웃하게 코딩하는 것을 선호한다. 책에서는 예시로 어떤 메서드가 최초로 호출되는 위치로부터 가까이 정의되어 있다면 코드의 가독성이 좋아진다고 한다.

생소한 언어 구성 요소를 다른 것으로 대체한다? 바로 람다식과 리스트 컴프리헨션과 같은 것들을 for 나 while로 바꿔보는 것을 예시로 들 수 있다. 

그리고 앞면에는 삼항 연산자나 람다 같은 고급 개념을 사용한 코드를 적고 뒷면에는 그에 해당하는 전통 방식의 코드를 적는 식으로 플래시카드를 활용할 수 있다.

코드를 집중해서 읽는 데 도움이 될 만한 보조 수단으로는
- 의존 그래프 생성
- 상태표 사용
- 의존 그래프, 상태표 혼용

이 있다. 먼저 의존 그래프를 만드는 방식은 다음과 같다.
1. 모든 변수를 원으로 표시한다.
2. 비슷한 변수를 연결한다.
3. 모든 메서드나 함수 호출을 1번과 다른 색의 원으로 표시한다.
4. 메서드나 함수 호출을 정의와 연결한다. 딱 한 번만 호출되는 메서드는 인라인으로 리팩터링할 수 있는 대상이다.
5. 클래스의 모든 인스턴스를 1번, 3번과 다른 색의 원으로 표시한다.
6. 클래스와 그것의 인스턴스를 연결한다.

의존 그래프로는 코드의 흐름을 보여주고 코드를 읽는 보조 수단으로 사용할 수 있다. 또한 이를 코드의 구조에 대한 정보를 가진 레퍼런스로 활용할 수 있다.

상태표를 만드는 방식은 다음과 같다.
1. 모든 변수를 나열한다.
2. 테이블을 만들고 각 열에 하나의 변수를 기입한다.
3. 코드의 실행 단계마다 행을 만든다.
4. 코드를 각 단계별로 실행하고 그 단계에서 변수들의 값을 해당 열과 행에 적는다.

어디서 많이 들어본 방식이다. 바로 정처산기를 준비할 때 알고리즘 과목에서 순서도 문제를 풀면서 작성한 그 상태표다. 아마 다들 상태표를 보면 "아 이거?" 하면서 단 번에 알아볼 것이다.  
개인적으로는 반복문이 많은 곳에서 꽤나 유용하게 썼던 것 같다.

# Part 2. 코드에 대해 생각하기

## Chapter 5. 코드를 더 깊이 있게 이해하기

코드에 대해 추론할 때는 변수가 중심적인 역할을 한다는 데에는 나도 동의한다. 그 변수를 요르마 사야니에미 교수가 다음의 11개 역할로 대부분의 변수를 설명할 수 있다고 한다.

1. 고정값(fixed value) - 초기화를 통해 값이 할당된 이후 값이 변경되지 않는 변수
2. 스테퍼(stepper) - 루프를 반복 실행하며 값이 단계적으로 변하는 변수, for문에서의 i 값
3. 플래그(flag) - 무엇인가 발생했거나 어떤 경우에 해당하는지를 나타내는 변수
4. 워커(walker) - 스테퍼처럼 자료구조를 순회하지만 루프가 시작되기 전에는 어떤 값을 가질지 알 수 없다. 포인터나 정수 인덱스가 그 예
5. 최근값 보유자(most recently holder) - 어떤 값이 변할 때 최근에 변경된 값을 갖는 변수
6. 목적값 보유자(most wanted holder) - 찾고자 하는 값 또는 조건에 부합하는 값을 갖는 변수
7. 모집자(gatherer) - 데이터를 모으거나 모은 데이터에 대해 어떤 연산을 수행하여 얻은 값을 저장하는 변수
8. 컨테이너(container) - 값을 새로 추가하거나 삭제할 수 있는 자료구조
9. 추적자(follower) - 이전 값 또는 다음 값을 추적, 이전 값에 대한 포인터나 조회한 원소의 인덱스
10. 조직자(organizer) - 다른 값을 저장하기 위한 목적으로 사용하는 변수
11. 임시(temporary) - 잠시 사용하기 위한 변수

이걸 '변수 역할 프레임워크'라고 하는데, 이를 도입하면 코드를 이해하고 의사소통 하는 데 도움이 된다고 한다. 내 생각엔 이 프레임워크를 집단이 전부 알고 있어야 효과가 있을 것 같다.  
저자는 각 변수 역할마다 아이콘을 지정해서 코드 내의 변수에 아이콘을 적어놓는다고 한다.

헝가리안 표기법에 대해서도 다뤘는데, 나는 개인적으로 헝가리안 표기법을 곧잘 쓰는 편이었다. 대학 다닐 때 C#을 전공으로 했던지라 버튼은 btn, 그리드뷰는 grv와 같은 접두사를 많이 썼다. 물론 타입별 접두사도 많이 썼다. Int 형이면 i, String 형이면 s를 변수 앞에 붙였다. 그런데 오늘날에는 보통 권장되지 않는다고 한다(이상하게 파이썬이나 자바를 할 때는 변수가 하는 일에 좀 더 집중해서 변수명을 지었다). 헝가리안 표기법도 시스템 헝가리안, 앱 헝가리안이 있는데, 내가 아는, 변수명에 변수의 타입을 나타내는 방식은 시스템 헝가리안이다. 앱 헝가리안은 단지 변수의 타입이 아니라, 배열의 길이를 나타내기 위해 `lX`와 같은 접두사를 쓰는 것처럼 구체적인 의미를 갖는다.

드디어 프로그램에 대해 깊이 있는 지식을 얻는 방법에 대해 보자면, 프로그램 이해의 단계는 다음과 같이 이루어진다.

1. 초점을 찾는다.
2. 초점으로부터 지식을 확장한다.
3. 관련된 개체로부터 개념을 이해한다.
4. 여러 개체에 걸쳐 있는 개념을 이해한다.

여기서 초점은 자바의 `main()`이나 웹 어플리케이션에서 `onLoad()` 같은 진입점이라고 한다(따라서 나는 앞으로 초점을 프로그램의 진입점으로 바꿔서 쓰겠다). 진입점은 코드를 어디서부터 읽을지에 대한 기준이므로 상당히 중요하다.

진입점을 찾으면 역할이 있는 관련 개체(변수, 메서드, 클래스)를 다 원으로 표시하고 비슷한 변수는 연결한다. 표시한 코드는 슬라이스라고 부르며, 어떤 한 라인 X의 슬라이스는 '라인 X와 관련 있는 모든 코드 라인'으로 정의한다. 슬라이스를 집중해서 살펴보면 프로그램의 어디에서 데이터가 사용되는지 이해하는 데 도움이 된다.

다음으로 표시한 슬라이스 내에서 여러 번 호출한 메서드가 있는지, 어떤 부분이 메서드 호출을 많이하는지 등을 찾아본다.

마지막으로 코드에 있는 서로 다른 개념들을 고수준에사 이해한다. 예로 코드에 있는 자료구조뿐만 아니라 해당 자료구조에 적용된 연산과 그 연산에 대한 제약도 이해한다. 또는 예외 처리에 대해서도 이해한다.

흥미로웠던 게 텍스트를 읽는 것과 코드를 읽는 것은 유사하다고 한다. 생각해보면 나는 책이나 글을 읽을 때 제목이나 목차를 먼저 읽고 글이 무슨 내용일지를 미리 추측하고 글을 읽는다. 그리고 코드를 볼 때에는 모듈 내의 메서드명이나 클래스명을 먼저 쭉 훑어보고 "대충 이 모듈은 이런 역할을 하는 개체들이 모여있겠구나." 하며 자세히 분석한다. 어찌보면 비슷한 패턴이다.

참고로 초급 프로그래머와 숙련된 프로그래머가 코드를 읽는 방식에 대한 실험 결과도 있었다. 초급 프로그래머는 약 75%가 순차적으로, 나머지가 콜 스택 흐름에 따라 코드를 읽었다. 반면 숙련된 프로그래머는 초급 프로그래머보다 더 많은 비율이 콜 스택 흐름에 따라 코드를 읽었다고 한다. 근데 콜 스택 흐름에 따라 코드를 안 읽으면 코드가 유기적으로 연결되는 게 아니라 뚝뚝 끊기는 느낌이 날텐데...

결과적으로 텍스트 이해 전략에서 비롯된 코드 읽기 전략은 다음과 같다.

1. 기존 지식의 활성화 - 그 코드가 무엇에 대한 것인지 파악
2. 모니터링 - 현재 무엇을 읽고 있는지, 이해는 하고 있는지를 추적. 이해되는 라인과 이해되지 않는 라인 표시
3. 코드에서 중요한 라인 결정 - 프로그램이 실행될 때 가장 중요한 영향을 끼치는 코드를 찾아 표시
4. 변수명의 의미를 추론하기 - 코드를 한 줄씩 따라가면서 모든 식별자(변수, 클래스, 메서드, 함수)의 이름 나열
5. 시각화 - 연산 테이블로 식별자 이름, 식별자와 관련된 연산 나열
6. 질문하기
    1. 코드에서 다섯 가지의 중심 개념은 무엇인가? 이 중심 개념이 식별자, 테마, 클래스 혹은 주석문 내의 정보로 나타나는가?
    2. 중심 개념을 찾기 위해 어떤 전략을 사용했는가? 예를 들어 메서드 이름, 문서 또는 변수명을 살펴봤다거나 아니면 시스템에 대해 이미 가지고 있는 지식을 활용했는가?
    3. 코드에서 발견되는 가장 중심적인 컴퓨터 과학의 중심 개념 다섯 가지는 무엇인가? 알고리즘, 자료구조, 가정, 사용된 기술 등이 이에 해당할 수 있다.
    4. 코드 작성자가 내린 결정 사항이 무엇인가? 예를 들면 특정 버전의 알고리즘을 구현하기로 한 결정, 특정 디자인 패턴을 사용하기로 한 결정, 특정 라이브러리나 API를 사용하기로 한 결정 등 말이다.
    5. 그런 결정을 내리는 데 상정한 가정은 무엇인가?
    6. 그 결정의 효과는 무엇인가?
    7. 그 결정의 잠재적 위험 요소는 무엇인가?
    8. 다른 해결책으로는 어떤 것이 있을까?
7. 코드 요약 - 코드의 목적, 가장 중요한 라인, 가장 관련 있는 도메인 개념, 가장 관련 있는 프로그래밍 구성 요소, 코드 작성 시 내린 결정

## Chapter 6. 코딩 문제 해결을 더 잘하려면

저자는 모델을 사용해서 코드에 대해 생각해볼 것을 추천한다. 모델은 실재를 간단하게 표현한 것으로,  프로그램에 대한 정보를 다른 사람과 공유할 때 유용하고, 문제를 풀 때 도움이 된다.

그 중에서도 두뇌의 바깥에서 만들어지지 않은 모델인 정신 모델이 있다. 나는 이걸 내 뇌속에서 만들어 낸, '내가 정의한 자신만의 개념'이라고 이해했다(이걸 이해해기까지 계속 그 챕터만 읽었고 사실 저게 맞는 표현인지도 모르겠다). 코드에 대해 생각할 때 정신 모델, 자신만의 개념을 효율적으로 사용하는 방법은 다음과 같다.

1. 국지적 모델을 만든다(localized를 국지적이라고 번역한 것 같은데, 나는 이걸 모듈 마다의 모델을 만든다고 이해했다). 상태표나 의존 그래프 등이 있다.
2. 코드에서 관련된 모든 객체와 객체 간의 관계를 나열한다.
3. 시스템에 대한 질문을 만들고 이 질문의 답을 사용해서 모델을 개선한다.
    1. 시스템에서 가장 중요한 요소(클래스, 객체, 페이지)는 무엇인거? 모델에 그것들이 포함되었는가?
    2. 이 중요한 요소들 사이의 관계는 무엇인가?
    3. 프로그램의 주요 목표는 무엇인가?
    4. 목표가 핵심 요소 및 그 관계와 어떻게 관련되어 있는가?
    5. 일반적인 사용 사례는 무엇인가? 모델이 그것을 보여주는가?

> 추가 업데이트 예정
